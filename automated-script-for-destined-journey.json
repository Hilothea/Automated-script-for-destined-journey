{
  "id": "03310a07-7f00-4aa9-8ad5-2259a88767f6",
  "name": "命定之诗与黄昏之歌自动化脚本",
  "content": "// ================================================================\n// 命定之诗与黄昏之歌自动化脚本 - 自动合并版本\n// 构建时间: 2025-10-02 20:54:09 UTC\n// 包含模块: config.js utils.js experience-level.js currency-system.js info-injection.js event-chain-system.js Key_level.js lock_HS.js main-controller.js\n// ================================================================\n\n// ======================== [Module: config.js] ========================\n(function() {\n    'use strict';\n    \n    // 里程碑等级配置\n    const MILESTONE_LEVELS = {\n        5: { strength: 1, agility: 1, constitution: 1, intelligence: 1, spirit: 1, tier: '第二层级/中坚' },\n        9: { strength: 1, agility: 1, constitution: 1, intelligence: 1, spirit: 1, tier: '第三层级/精英' },\n        13: { strength: 1, agility: 1, constitution: 1, intelligence: 1, spirit: 1, tier: '第四层级/史诗' },\n        17: { strength: 1, agility: 1, constitution: 1, intelligence: 1, spirit: 1, tier: '第五层级/传说' },\n        21: { strength: 1, agility: 1, constitution: 1, intelligence: 1, spirit: 1, tier: '第六层级/神话' },\n        25: { strength: 1, agility: 1, constitution: 1, intelligence: 1, spirit: 1, tier: '第七层级/神祗' }\n    };\n    \n    // 职业等级经验表\n    const JOB_LEVEL_XP_TABLE = {\n        0: 0, 1: 1276, 2: 5052, 3: 11623, 4: 21299, 5: 34395, 6: 51228, 7: 72116, 8: 97377, 9: 127331,\n        10: 162306, 11: 202642, 12: 248680, 13: 300761, 14: 359228, 15: 424423, 16: 496690, 17: 576373, 18: 663816, 19: 759362,\n        20: 863357, 21: 1004144, 22: 1332608, 23: 4427488, 24: 6666666, 25: 1145141919810\n    };\n\n    // 核心游戏配置\n    const GAME_CONFIG = {\n        PP_TO_GP: 10,              // 铂到金\n        GP_TO_SP: 10,               // 金到银\n        SP_TO_CP: 10,               // 银到铜\n        AP_Acquisition_Level: 1,    // 每X级获得属性点\n        Key_level: 13               //关键等级13\n    };\n\n    // 将配置暴露给全局范围\n    window.MILESTONE_LEVELS = MILESTONE_LEVELS;\n    window.JOB_LEVEL_XP_TABLE = JOB_LEVEL_XP_TABLE;\n    window.GAME_CONFIG = GAME_CONFIG;\n})();\n\n\n// ======================== [Module: utils.js] ========================\n(function() {\n    'use strict';\n    \n    /**\n     * 安全的浮点数解析函数\n     * @param {*} value - 要解析的值\n     * @returns {number} - 解析后的数值，如果解析失败则返回0\n     */\n    function safeParseFloat(value) {\n        const num = parseFloat(value);\n        return isNaN(num) ? 0 : num;\n    }\n\n    /**\n     * 解除注入的提示信息\n     * @param {Array<string>} idsToRemove - 要移除的ID数组\n     */\n    function uninject() {\n        const idsToRemove = [\n            'AP+',\n            'currency_deficit',\n            'Location',\n            'Time',\n            'LV+',\n            'Key_level'\n        ];\n        uninjectPrompts(idsToRemove);\n    }\n\n    // 将工具函数暴露给全局范围\n    window.safeParseFloat = safeParseFloat;\n    window.uninject = uninject;\n})();\n\n\n// ======================== [Module: experience-level.js] ========================\n(function() {\n    'use strict';\n    \n    /**\n     * 经验与等级处理模块\n     * @param {Object} user - 用户对象\n     */\n    function experiencegrowth(user) {\n        // 校准升级所需经验\n        user.状态.升级所需经验[0] = window.JOB_LEVEL_XP_TABLE[user.状态.等级[0]];\n        \n        const currentLevel = user.状态.等级[0];\n        \n        // 确保累计经验值不低于前一级的要求\n        if (currentLevel > 0) {\n            const requiredXpForPreviousLevel = window.JOB_LEVEL_XP_TABLE[currentLevel - 1];\n            if (window.safeParseFloat(user.状态.累计经验值[0]) < requiredXpForPreviousLevel) {\n                user.状态.累计经验值[0] = requiredXpForPreviousLevel;\n            }\n        }\n        \n        let hasLeveledUp = false;\n        \n        // 升级处理循环\n        while (window.safeParseFloat(user.状态.累计经验值[0]) >= window.safeParseFloat(user.状态.升级所需经验[0])) {\n            if (!window.JOB_LEVEL_XP_TABLE[user.状态.等级[0]]) { \n                break; \n            }\n            \n            user.状态.等级[0] = window.safeParseFloat(user.状态.等级[0]) + 1;\n            hasLeveledUp = true;\n            user.状态.升级所需经验[0] = window.JOB_LEVEL_XP_TABLE[user.状态.等级[0]];\n            \n            // 检查是否获得属性点\n            if (user.状态.等级[0] % window.GAME_CONFIG.AP_Acquisition_Level === 0) {\n                user.属性.属性点[0] = window.safeParseFloat(user.属性.属性点[0]) + 1;\n                injectPrompts([{\n                    id: 'AP+',\n                    position: 'in_chat',\n                    role: 'system',\n                    depth: 0,\n                    content: 'core_system: The {{user}} has reached a specific level and obtained attribute points. Guide the {{user}} to use attribute points',\n                    should_scan: true\n                }]);\n            }\n            \n            // 检查里程碑等级\n            const milestone = window.MILESTONE_LEVELS[user.状态.等级[0]];\n            if (milestone) {\n                user.属性.力量[0] = window.safeParseFloat(user.属性.力量[0]) + milestone.strength;\n                user.属性.敏捷[0] = window.safeParseFloat(user.属性.敏捷[0]) + milestone.agility;\n                user.属性.体质[0] = window.safeParseFloat(user.属性.体质[0]) + milestone.constitution;\n                user.属性.智力[0] = window.safeParseFloat(user.属性.智力[0]) + milestone.intelligence;\n                user.属性.精神[0] = window.safeParseFloat(user.属性.精神[0]) + milestone.spirit;\n                user.状态.生命层级[0] = milestone.tier;\n            }\n        }\n        \n        // 如果升级了，注入升级提示\n        if (hasLeveledUp) {\n            injectPrompts([{\n                id: 'LV+',\n                position: 'in_chat',\n                role: 'system',\n                depth: 0,\n                content: `core_system: The {{user}} level increased from ${currentLevel} to ${user.状态.等级[0]}`,\n                should_scan: true\n            }]);\n        }\n    }\n\n    // 将函数暴露给全局范围\n    window.experiencegrowth = experiencegrowth;\n})();\n\n\n// ======================== [Module: currency-system.js] ========================\n(function() {\n    'use strict';\n    \n    /**\n     * 货币系统模块 - 处理货币按需换算\n     * @param {Object} property - 财产对象\n     */\n    function CurrencySystem(property) {\n        let PP = window.safeParseFloat(property.货币.白金币[0]); \n        let GP = window.safeParseFloat(property.货币.金币[0]);   \n        let SP = window.safeParseFloat(property.货币.银币[0]);   \n        let CP = window.safeParseFloat(property.货币.铜币[0]);   \n        \n        // 按需换算函数\n        function handleCurrencyExchange() {\n            let deficit = 0;\n            let currencyCleared = false;\n            \n            // PP购买处理：PP被扣成负时的换算逻辑\n            if (PP < 0) {\n                let ppDeficit = Math.abs(PP);\n                \n                // 优先用GP抵扣 (1PP = 100GP)\n                if (GP >= ppDeficit * window.GAME_CONFIG.PP_TO_GP) {\n                    GP -= ppDeficit * window.GAME_CONFIG.PP_TO_GP;\n                    PP = 0;\n                } else {\n                    // GP不足，用完所有GP，剩余用SP换GP\n                    let remainingDeficit = ppDeficit * window.GAME_CONFIG.PP_TO_GP - GP;\n                    GP = 0;\n                    \n                    // 尝试用SP换GP (1GP = 10SP)\n                    if (SP >= remainingDeficit * window.GAME_CONFIG.GP_TO_SP) {\n                        SP -= remainingDeficit * window.GAME_CONFIG.GP_TO_SP;\n                        PP = 0;\n                    } else {\n                        // SP不足，用完所有SP，剩余用CP换SP\n                        remainingDeficit = remainingDeficit * window.GAME_CONFIG.GP_TO_SP - SP;\n                        SP = 0;\n                        \n                        // 尝试用CP换SP (1SP = 10CP)\n                        if (CP >= remainingDeficit * window.GAME_CONFIG.SP_TO_CP) {\n                            CP -= remainingDeficit * window.GAME_CONFIG.SP_TO_CP;\n                            PP = 0;\n                        } else {\n                            // 无法完全覆盖，清零PP、GP、SP，差值转换为CP并记录\n                            deficit = remainingDeficit * window.GAME_CONFIG.SP_TO_CP - CP;\n                            PP = GP = SP = 0;\n                            CP = -deficit; // 负CP表示欠债\n                            currencyCleared = true;\n                        }\n                    }\n                }\n            }\n            \n            // GP购买处理：GP被扣成负时的换算逻辑\n            if (GP < 0 && !currencyCleared) {\n                let gpDeficit = Math.abs(GP);\n                \n                // 优先用PP抵扣 (1PP = 100GP)\n                if (PP >= Math.ceil(gpDeficit / window.GAME_CONFIG.PP_TO_GP)) {\n                    let ppNeeded = Math.ceil(gpDeficit / window.GAME_CONFIG.PP_TO_GP);\n                    PP -= ppNeeded;\n                    GP = ppNeeded * window.GAME_CONFIG.PP_TO_GP - gpDeficit;\n                } else {\n                    // PP不足，用完所有PP，剩余用SP换GP\n                    let remainingDeficit = gpDeficit - PP * window.GAME_CONFIG.PP_TO_GP;\n                    PP = 0;\n                    \n                    // 尝试用SP换GP (1GP = 10SP)\n                    if (SP >= remainingDeficit * window.GAME_CONFIG.GP_TO_SP) {\n                        SP -= remainingDeficit * window.GAME_CONFIG.GP_TO_SP;\n                        GP = 0;\n                    } else {\n                        // SP不足，用完所有SP，剩余用CP换SP\n                        remainingDeficit = remainingDeficit * window.GAME_CONFIG.GP_TO_SP - SP;\n                        SP = 0;\n                        \n                        // 尝试用CP换SP (1SP = 10CP)\n                        if (CP >= remainingDeficit * window.GAME_CONFIG.SP_TO_CP) {\n                            CP -= remainingDeficit * window.GAME_CONFIG.SP_TO_CP;\n                            GP = 0;\n                        } else {\n                            // 无法完全覆盖，清零PP、GP、SP，差值转换为CP并记录\n                            deficit = remainingDeficit * window.GAME_CONFIG.SP_TO_CP - CP;\n                            PP = GP = SP = 0;\n                            CP = -deficit; // 负CP表示欠债\n                            currencyCleared = true;\n                        }\n                    }\n                }\n            }\n            \n            // SP购买处理：SP被扣成负时的换算逻辑\n            if (SP < 0 && !currencyCleared) {\n                let spDeficit = Math.abs(SP);\n                \n                // 优先用PP抵扣 (1PP = 1000SP)\n                if (PP >= Math.ceil(spDeficit / (window.GAME_CONFIG.PP_TO_GP * window.GAME_CONFIG.GP_TO_SP))) {\n                    let ppNeeded = Math.ceil(spDeficit / (window.GAME_CONFIG.PP_TO_GP * window.GAME_CONFIG.GP_TO_SP));\n                    PP -= ppNeeded;\n                    SP = ppNeeded * window.GAME_CONFIG.PP_TO_GP * window.GAME_CONFIG.GP_TO_SP - spDeficit;\n                } else {\n                    // PP不足，用完所有PP，剩余用GP换SP\n                    let remainingDeficit = spDeficit - PP * window.GAME_CONFIG.PP_TO_GP * window.GAME_CONFIG.GP_TO_SP;\n                    PP = 0;\n                    \n                    // 尝试用GP换SP (1GP = 10SP)\n                    if (GP >= Math.ceil(remainingDeficit / window.GAME_CONFIG.GP_TO_SP)) {\n                        let gpNeeded = Math.ceil(remainingDeficit / window.GAME_CONFIG.GP_TO_SP);\n                        GP -= gpNeeded;\n                        SP = gpNeeded * window.GAME_CONFIG.GP_TO_SP - remainingDeficit;\n                    } else {\n                        // GP不足，用完所有GP，剩余用CP换SP\n                        remainingDeficit = remainingDeficit - GP * window.GAME_CONFIG.GP_TO_SP;\n                        GP = 0;\n                        \n                        // 尝试用CP换SP (1SP = 10CP)\n                        if (CP >= remainingDeficit * window.GAME_CONFIG.SP_TO_CP) {\n                            CP -= remainingDeficit * window.GAME_CONFIG.SP_TO_CP;\n                            SP = 0;\n                        } else {\n                            // 无法完全覆盖，清零PP、GP、SP，差值转换为CP并记录\n                            deficit = remainingDeficit * window.GAME_CONFIG.SP_TO_CP - CP;\n                            PP = GP = SP = 0;\n                            CP = -deficit; // 负CP表示欠债\n                            currencyCleared = true;\n                        }\n                    }\n                }\n            }\n            \n            // CP购买处理：CP被扣成负时的换算逻辑\n            if (CP < 0 && !currencyCleared) {\n                let cpDeficit = Math.abs(CP);\n                \n                // 优先用PP抵扣 (1PP = 10000CP)\n                if (PP >= Math.ceil(cpDeficit / (window.GAME_CONFIG.PP_TO_GP * window.GAME_CONFIG.GP_TO_SP * window.GAME_CONFIG.SP_TO_CP))) {\n                    let ppNeeded = Math.ceil(cpDeficit / (window.GAME_CONFIG.PP_TO_GP * window.GAME_CONFIG.GP_TO_SP * window.GAME_CONFIG.SP_TO_CP));\n                    PP -= ppNeeded;\n                    CP = ppNeeded * window.GAME_CONFIG.PP_TO_GP * window.GAME_CONFIG.GP_TO_SP * window.GAME_CONFIG.SP_TO_CP - cpDeficit;\n                } else {\n                    // PP不足，用完所有PP，剩余用GP换CP\n                    let remainingDeficit = cpDeficit - PP * window.GAME_CONFIG.PP_TO_GP * window.GAME_CONFIG.GP_TO_SP * window.GAME_CONFIG.SP_TO_CP;\n                    PP = 0;\n                    \n                    // 尝试用GP换CP (1GP = 100CP)\n                    if (GP >= Math.ceil(remainingDeficit / (window.GAME_CONFIG.GP_TO_SP * window.GAME_CONFIG.SP_TO_CP))) {\n                        let gpNeeded = Math.ceil(remainingDeficit / (window.GAME_CONFIG.GP_TO_SP * window.GAME_CONFIG.SP_TO_CP));\n                        GP -= gpNeeded;\n                        CP = gpNeeded * window.GAME_CONFIG.GP_TO_SP * window.GAME_CONFIG.SP_TO_CP - remainingDeficit;\n                    } else {\n                        // GP不足，用完所有GP，剩余用SP换CP\n                        remainingDeficit = remainingDeficit - GP * window.GAME_CONFIG.GP_TO_SP * window.GAME_CONFIG.SP_TO_CP;\n                        GP = 0;\n                        \n                        // 尝试用SP换CP (1SP = 10CP)\n                        if (SP >= Math.ceil(remainingDeficit / window.GAME_CONFIG.SP_TO_CP)) {\n                            let spNeeded = Math.ceil(remainingDeficit / window.GAME_CONFIG.SP_TO_CP);\n                            SP -= spNeeded;\n                            CP = spNeeded * window.GAME_CONFIG.SP_TO_CP - remainingDeficit;\n                        } else {\n                            // 无法完全覆盖，清零PP、GP、SP，差值转换为CP并记录\n                            deficit = remainingDeficit - SP * window.GAME_CONFIG.SP_TO_CP;\n                            PP = GP = SP = 0;\n                            CP = -deficit; // 负CP表示欠债\n                            currencyCleared = true;\n                        }\n                    }\n                }\n            }\n            \n            return { deficit, currencyCleared };\n        }\n        \n        // 执行按需换算\n        const result = handleCurrencyExchange();\n        \n        // 处理无法覆盖的情况\n        if (result.currencyCleared && result.deficit > 0) {\n            window.injectPrompts([{\n                id: 'currency_deficit',\n                content: `core_system:warning {{user}}货币不足,差值为${result.deficit}铜币,你需要通过红线系统助手提醒{{user}}并提醒{{user}}即使偿还`,\n                position: 'in_chat',\n                depth: 0,\n                role: 'system',\n                should_scan: true,\n            }]);\n        }\n        \n        // 更新货币值\n        property.货币.白金币[0] = Math.max(0, Math.floor(PP));\n        property.货币.金币[0] = Math.max(0, Math.floor(GP));\n        property.货币.银币[0] = Math.max(0, Math.floor(SP));\n        property.货币.铜币[0] = Math.floor(CP); // CP可以为负数，表示欠债\n    }\n\n    // 将函数暴露给全局范围\n    window.CurrencySystem = CurrencySystem;\n})();\n\n\n// ======================== [Module: info-injection.js] ========================\n(function() {\n    'use strict';\n    \n    /**\n     * 信息读取与注入模块\n     * @param {Object} world - 世界对象\n     */\n    function inforead(world) {\n        // 注入地点信息\n        injectPrompts([{\n            id: 'Location',\n            content: world.地点[0],\n            position: 'none',\n            depth: 0,\n            role: 'system',\n            should_scan: true,\n        }]);\n        \n        // 注入时间信息\n        injectPrompts([{\n            id: 'Time',\n            content: world.时间[0],\n            position: 'none',\n            depth: 0,\n            role: 'system',\n            should_scan: true,\n        }]);\n    }\n\n    // 将函数暴露给全局范围\n    window.inforead = inforead;\n})();\n\n\n// ======================== [Module: event-chain-system.js] ========================\n(function() {\n    'use strict';\n    \n    /**\n     * 事件链处理模块\n     * @param {Object} eventchain - 事件链对象\n     */\n    function event_chain(eventchain) {\n        if (eventchain.开启[0] === 'true') {\n            // 清除之前的事件链注入\n            uninjectPrompts(['event_chain']);\n            uninjectPrompts(['event_chain_tips']);\n            \n            const title = eventchain.标题[0];\n            const step = eventchain.大狗叫[0];\n            \n            // 注入当前事件链状态\n            injectPrompts([{\n                id: 'event_chain',\n                content: `当前事件为${title}，当前步骤为${step}`,\n                position: 'none',\n                depth: 0,\n                role: 'system',\n                should_scan: true,\n            }]);\n            \n            // 注入事件链激活提示\n            injectPrompts([{\n                id: 'event_chain_tips',\n                content: `core_system:事件链${title}已激活,注意<event_chain>`,\n                position: 'in_chat',\n                depth: 0,\n                role: 'system',\n                should_scan: true,\n            }]);\n            \n            // 检查是否结束事件链\n            if (eventchain.结束[0] === 'true') {\n                uninjectPrompts(['event_chain']);\n                uninjectPrompts(['event_chain_tips']);\n                eventchain.标题[0] = 'null';\n                eventchain.大狗叫[0] = 'null';\n                eventchain.结束[0] = 'false';\n                eventchain.开启[0] = 'false';\n            }\n        }\n    }\n    // 将函数暴露给全局范围\n    window.event_chain = event_chain;\n})();\n\n\n// ======================== [Module: Key_level.js] ========================\n(function() {\n    'use strict';\n    function Key_level(user) {\n        if(user.状态.等级[0] >= window.GAME_CONFIG.Key_level){\n        injectPrompts([{\n            id: 'Key_level',\n            position: 'none',\n            role: 'system',\n            depth: 0,\n            content: 'user_lv>=13',\n            should_scan: true\n        }]);\n        }\n    }\n    window.Key_level = Key_level;\n})();\n\n\n// ======================== [Module: lock_HS.js] ========================\n(function() {\n    'use strict';\n    \n    function Lock_favorability(fatesystem) {\n        let favorability_S = fatesystem.希尔薇娅.好感度\n        let favorability_H = fatesystem.希洛西娅.好感度\n        if (favorability_S >= 40) {\n            avorability_S = 39\n            fatesystem.希尔薇娅.好感度 = avorability_S\n        }\n        if(favorability_H >= 40){\n            favorability_H = 39\n            fatesystem.希洛西娅.好感度 = favorability_H\n        }\n    }\n    window.Lock_favorability = Lock_favorability;\n})();\n\n\n// ======================== [Module: main-controller.js] ========================\n(function() {\n    'use strict';\n    \n    /**\n     * 主流程控制函数\n     * @param {Object} variables - 包含所有游戏数据的变量对象\n     */\n    function Main_processes(variables) {\n        // 获取变量\n        const user = variables.stat_data?.角色; \n        const property = variables?.stat_data?.财产; \n        const world = variables?.stat_data?.世界; \n        const eventchain = variables.stat_data?.事件链;\n        const fatesystem = ariables.stat_data?.命运系统;\n        \n        if (!user || !property || !world || !eventchain || !fatesystem) {\n            console.error(\"Core data missing, script terminated\");\n            return;\n        }\n        \n        // 按照顺序执行模块\n        window.Lock_favorability(fatesystem);\n        window.uninject();                           // 1. 解除注入\n        window.experiencegrowth(user);               // 2. 经验与等级处理\n        window.CurrencySystem(property);             // 3. 货币换算\n        window.inforead(world);                      // 4. 信息读取与注入\n        window.event_chain(eventchain);              // 6. 事件链处理\n        window.Key_level(user);                      //7.关键等级检测\n    }\n\n    // 将主函数暴露给全局范围\n    window.Main_processes = Main_processes;\n\n    // ============================ [事件监听] ============================\n    // 监听变量更新完成事件\n    eventOn('mag_variable_update_ended', Main_processes);\n    \n    // 监听按钮事件\n    eventOnButton('重新处理变量', Main_processes);\n})();\n\n\n",
  "info": "## 模块结构\n\n### 1. 配置模块 (`config.js`)\n- **版本/更新时间**: v0.1/25.9.24\n- **功能**: 管理所有游戏配置常量\n- **包含内容**:\n  - `MILESTONE_LEVELS`: 里程碑等级配置\n  - `JOB_LEVEL_XP_TABLE`: 职业等级经验表\n  - `GAME_CONFIG`: 核心游戏配置参数\n\n### 2. 工具函数 (`utils.js`)\n- **版本/更新时间**: v0.1/25.9.24\n- **功能**: 提供通用工具函数\n- **包含内容**:\n  - `safeParseFloat()`: 安全的浮点数解析\n  - `uninject()`: 解除注入功能\n\n### 3. 经验等级处理 (`experience-level.js`)\n- **版本/更新时间**: v0.1/25.9.24\n- **功能**: 处理角色经验值和等级提升\n- **主要函数**: `experiencegrowth(user)`\n- **特性**:\n  - 自动升级处理\n  - 属性点获得\n  - 里程碑奖励\n  - 升级提示注入\n\n### 4. 属性校准 (`attribute-calibration.js`);暂时弃用\n- **版本/更新时间**: v0.1/25.9.24\n- **功能**: 计算和校准角色的HP、MP、SP\n- **主要函数**: `attributecalibration(user)`\n- **特性**:\n  - 基础属性计算\n  - 倍率和额外值处理\n  - 上限值校准\n  \n### 5. 货币系统 (`currency-system.js`)\n- **作者注**: v0.2不是我写的是Claude写的\n- **版本/更新时间**: v0.2/25.9.26\n- **功能**: 处理游戏内货币按需换算（无自动进位）\n- **主要函数**: `CurrencySystem(property)`\n- **特性**:\n  - **按需换算逻辑**: \n    - PP购买：PP被扣成负时，优先用GP抵扣，GP不足则尝试用SP换GP，SP不足则尝试用CP换SP\n    - GP购买：GP被扣成负时，优先用PP抵扣，PP不足则尝试用SP换GP，SP不足则尝试用CP换SP\n    - SP/CP购买：按相同逻辑处理\n  - **换算比例**: 1 PP = 100 GP = 1000 SP = 10000 CP\n  - **不足处理**: 能覆盖→完成换算；不能覆盖→PP、GP、SP清零，差值记录为负CP（表示欠债）\n  - **破产提醒**: 使用injectPrompts播报详细差值信息\n  - **测试支持**: 包含currency-test.html测试页面\n\n### 6. 信息注入 (`info-injection.js`)\n- **版本/更新时间**: v0.1/25.9.24\n- **功能**: 向游戏注入环境信息\n- **主要函数**: `inforead(world)`\n- **特性**:\n  - 地点信息注入\n  - 时间信息注入\n\n### 7. 事件链系统 (`event-chain-system.js`)\n- **版本/更新时间**: v0.1/25.9.24\n- **功能**: 管理游戏事件链\n- **主要函数**:\n  - `event_chain(eventchain)`: 处理事件链\n- **特性**:\n  - 事件链激活/停用\n  - 状态跟踪\n  - 提示注入\n\n### 8. 关键等级检测 (`Key_level.js`)\n- **版本/更新时间**: v0.2/25.9.26\n- **功能**: 检测用户是否达到关键等级阈值\n- **主要函数**: `Key_level(user)`\n- **特性**:\n  - 关键等级阈值检测（默认60级）\n  - 自动系统提示注入\n  - 可配置阈值设置\n\n### 9. 主流程控制 (`main-controller.js`)\n- **版本/更新时间**: v0.2/25.9.26\n- **功能**: 协调所有模块的执行\n- **主要函数**: `Main_processes(variables)`\n- **特性**:\n  - 模块执行顺序控制\n  - 事件监听器注册\n  - 错误处理\n\n## 使用方法\n\n### 单独使用模块\n每个模块都可以独立使用：\n\n```javascript\n// 例如：只使用货币系统\n// 在主流程控制模块中使用//注释不需要启用的模块\n//例如:\nwindow.uninject();                           // 1. 解除注入\n//window.experiencegrowth(user);               // 2. 经验与等级处理\nwindow.CurrencySystem(property);             // 3. 货币换算\n//window.inforead(world);                      // 4. 信息读取与注入\n//window.event_chain(eventchain);              // 6. 事件链处理\n//window.Key_level(user);                      // 7. 关键等级检测\n```\n\n## 兼容性说明\n\n- 所有模块都使用 `window` 对象来暴露函数，确保跨模块访问\n\n## 维护优势\n\n1. **模块化**: 每个功能独立，便于维护和调试\n2. **可复用**: 模块可以在其他项目中重复使用\n3. **清晰结构**: 代码组织更加清晰\n4. **易于扩展**: 可以轻松添加新功能模块\n5. **版本控制**: 可以独立更新各个模块\n\n## 注意事项\n\n- 确保按正确顺序加载脚本\n- 所有模块都依赖于 `config.js` 和 `utils.js`\n- `main-controller.js` 包含事件监听器，必须最后加载\n- 如果修改配置，只需要更新 `config.js` 文件\n",
  "buttons": [],
  "data": {}
}